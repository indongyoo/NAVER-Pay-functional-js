<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>4.1</title>
</head>
<body>

<script src="fx.js"></script>

1. 비동기/동시성 프로그래밍
- callback과 Promise
- 비동기를 값으로 만드는 Promise
- 값으로서의 Promise 활용
<script type="module">
function add10(a) {
  return new Promise(resolve => setTimeout(() => resolve(a + 10), 1000));
}
add10(5)
  .then(add10)
  .then(add10)
  // .then(log);

const pa = add10(5);
// log(pa);
const go1 = (a, f) => a instanceof Promise ? a.then(f) : f(a);

// go1(10, log);
// go1(Promise.resolve(10), log);
</script>

- 합성 관점에서의 Promise
<script type="module">
const f = ({a}) => ({ a: a + 1 });
const g = ({a}) => ({ a: a - 1 });
const g2 = ({a}) => Promise.resolve({ a: a - 1 });
const x = {a: 10};
// log(f(g(x)));
// log(f(g()));

// Array.of(x).map(g).map(f).forEach(a => log(a));
// Array.of(x, {a: 11}).map(g).map(f).forEach(a => log(a));
// Array.of().map(g).map(f).forEach(a => log(a));

// Promise.resolve(x).then(g).then(f).then(a => log(a));
// Promise.resolve(x).then(g2).then(f).then(a => log(a));

// Promise.resolve(Promise.resolve(1)).then(a => log(a + 10));

Promise.resolve({a: 1})
  .then(({a}) => a + 10)
  .then(b => b + 20)
  // .then(log);

const nop = Symbol.for('nop');

const pa = Promise.resolve(10);

const pb = pa.then(a => isNaN(a) ? Promise.reject(nop) : a).then(a => a + 10);

const pc = pb.then(b => b + 20);

// const pd = pc.then(log)
  // .catch(a => a == nop ? log('nop~') : Promise.reject(a));

// pd.catch(e => console.error(e, 'hi~'));

// f(g(x)) = g(x)
</script>

- go, reduce에서 비동기 제어
<script type="module">
// go(Promise.resolve(10),
//   a => Promise.resolve(a + 10),
//   a => Promise.resolve(a + 10),
//   log);

async function f() {
  const a = await go(
    [1,2,3,4,5,6],
    L.filter(a => a % 2),
    reduce((a, b) => Promise.resolve(a + b)));

  log(a);
  return a + 10;
}
f().then(a => log(a));
</script>

2. 비동기 제어에 앞서
- range, take의 재해석
<script type="module">
const list = [1, 2, 3, 4, 5, 6, 7, 8, 9];

const chunkArray = (n, arr) => {
  const iter = toIter(arr);
  return go(
    L.range(0, Math.ceil(arr.length / n)),
    map(_ => take(n, iter)));
};

L.chunk = (n, iter) => {
  iter = toIter(iter);
  return go(
    L.range(0, Infinity),
    L.map(_ => take(n, iter)),
    L.takeWhile(a => a.length));
};

const chunk = pipe(L.chunk, takeAll);

log(chunk(3, list));
log(chunk(4, list));
log(chunk(3, function* () {
  yield 10;
  yield 10;
  yield 10;
  yield 10;
  yield 10;
  yield 10;
  yield 10;
} ()));
</script>


</body>
</html>